<!doctype html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>AI Context Studio</title>
        <style>
            @import url("https://fonts.googleapis.com/css2?family=DM+Sans:wght@400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap");

            :root {
                --bg-dark: #08090c;
                --bg-panel: rgba(16, 18, 24, 0.85);
                --bg-hover: rgba(255, 255, 255, 0.04);
                --bg-active: rgba(99, 102, 241, 0.08);
                --border: rgba(255, 255, 255, 0.07);
                --border-focus: rgba(99, 102, 241, 0.5);
                --text-main: #e2e4e9;
                --text-muted: #6b7280;
                --accent: #6366f1;
                --accent-hover: #4f46e5;
                --accent-glow: rgba(99, 102, 241, 0.15);
                --danger: #ef4444;
                --danger-bg: rgba(239, 68, 68, 0.1);
                --success: #34d399;
                --warning: #fbbf24;
                --folder-color: #fbbf24;
                --file-color: #60a5fa;
                --font-sans: "DM Sans", system-ui, sans-serif;
                --font-mono: "JetBrains Mono", monospace;
                --radius: 8px;
                --radius-lg: 12px;
                --transition: 0.15s ease;
            }

            *,
            *::before,
            *::after {
                box-sizing: border-box;
                margin: 0;
                padding: 0;
            }

            body {
                font-family: var(--font-sans);
                background: var(--bg-dark);
                color: var(--text-main);
                height: 100vh;
                overflow: hidden;
                display: flex;
            }

            /* Scrollbar */
            ::-webkit-scrollbar {
                width: 6px;
                height: 6px;
            }
            ::-webkit-scrollbar-track {
                background: transparent;
            }
            ::-webkit-scrollbar-thumb {
                background: rgba(255, 255, 255, 0.1);
                border-radius: 3px;
            }
            ::-webkit-scrollbar-thumb:hover {
                background: rgba(255, 255, 255, 0.2);
            }

            /* Utility */
            .hidden {
                display: none !important;
            }
            .mono {
                font-family: var(--font-mono);
            }
            .muted {
                color: var(--text-muted);
            }
            .text-xs {
                font-size: 0.75rem;
            }
            .text-sm {
                font-size: 0.8125rem;
            }
            .text-green {
                color: var(--success);
            }
            .text-yellow {
                color: var(--folder-color);
            }
            .text-blue {
                color: var(--file-color);
            }

            /* Layout */
            #app {
                display: flex;
                width: 100%;
                height: 100%;
            }

            .panel {
                background: var(--bg-panel);
                backdrop-filter: blur(16px);
                -webkit-backdrop-filter: blur(16px);
                display: flex;
                flex-direction: column;
                padding: 1rem;
            }
            #left-panel {
                flex: 1;
                max-width: 440px;
                border-right: 1px solid var(--border);
            }
            #right-panel {
                flex: 1.2;
                border-left: 1px solid var(--border);
            }

            /* Inputs */
            input[type="text"],
            textarea {
                background: rgba(0, 0, 0, 0.35);
                border: 1px solid var(--border);
                color: var(--text-main);
                border-radius: var(--radius);
                padding: 0.6rem 0.75rem;
                font-family: var(--font-mono);
                font-size: 0.8125rem;
                outline: none;
                transition: border var(--transition);
            }
            input[type="text"]:focus,
            textarea:focus {
                border-color: var(--border-focus);
            }

            /* Buttons */
            button {
                background: rgba(255, 255, 255, 0.04);
                border: 1px solid var(--border);
                color: var(--text-main);
                padding: 0.375rem 0.75rem;
                border-radius: var(--radius);
                cursor: pointer;
                font-family: var(--font-sans);
                font-size: 0.8125rem;
                transition: all var(--transition);
                display: inline-flex;
                align-items: center;
                justify-content: center;
                gap: 0.375rem;
                white-space: nowrap;
            }
            button:hover {
                background: rgba(255, 255, 255, 0.08);
            }
            button.primary {
                background: var(--accent);
                border-color: var(--accent);
            }
            button.primary:hover {
                background: var(--accent-hover);
                box-shadow: 0 0 16px var(--accent-glow);
            }
            button:disabled {
                opacity: 0.4;
                cursor: not-allowed;
            }

            /* Checkbox */
            input[type="checkbox"] {
                appearance: none;
                width: 15px;
                height: 15px;
                border: 1px solid rgba(255, 255, 255, 0.25);
                border-radius: 3px;
                background: rgba(0, 0, 0, 0.2);
                cursor: pointer;
                position: relative;
                display: grid;
                place-content: center;
                flex-shrink: 0;
                transition: all 0.15s;
            }
            input[type="checkbox"]::before {
                content: "";
                width: 9px;
                height: 9px;
                transform: scale(0);
                box-shadow: inset 1em 1em var(--text-main);
                transform-origin: center;
                clip-path: polygon(
                    14% 44%,
                    0 65%,
                    50% 100%,
                    100% 16%,
                    80% 0%,
                    43% 62%
                );
                transition: 100ms transform ease-in-out;
            }
            input[type="checkbox"]:checked {
                background: var(--accent);
                border-color: var(--accent);
            }
            input[type="checkbox"]:checked::before {
                transform: scale(1);
            }
            input[type="checkbox"]:indeterminate {
                background: var(--accent);
                border-color: var(--accent);
            }
            input[type="checkbox"]:indeterminate::before {
                clip-path: polygon(0 40%, 100% 40%, 100% 60%, 0 60%);
                transform: scale(1);
            }

            /* Drop zone */
            #drop-zone {
                flex: 1;
                display: flex;
                flex-direction: column;
                align-items: center;
                justify-content: center;
                border: 2px dashed rgba(255, 255, 255, 0.1);
                border-radius: var(--radius-lg);
                margin: 1rem;
                transition: all var(--transition);
                cursor: pointer;
                text-align: center;
            }
            #drop-zone.dragover {
                border-color: var(--accent);
                background: var(--accent-glow);
            }
            #drop-zone svg {
                width: 40px;
                height: 40px;
                color: var(--text-muted);
                margin-bottom: 0.75rem;
            }
            #drop-zone h3 {
                font-size: 0.9375rem;
                font-weight: 600;
                margin-bottom: 0.25rem;
            }

            /* Tree */
            #tree-container {
                flex: 1;
                overflow-y: auto;
                overflow-x: hidden;
                margin-top: 0.75rem;
                padding-right: 0.25rem;
            }
            details {
                margin-left: 1rem;
            }
            #tree-container > details,
            #tree-container > .file-item {
                margin-left: 0;
            }

            summary {
                display: flex;
                align-items: center;
                gap: 0.4rem;
                padding: 0.2rem 0.4rem;
                border-radius: 4px;
                cursor: pointer;
                list-style: none;
                font-size: 0.8125rem;
            }
            summary::-webkit-details-marker {
                display: none;
            }
            summary:hover,
            .file-item:hover {
                background: var(--bg-hover);
            }

            .file-item {
                display: flex;
                align-items: center;
                gap: 0.4rem;
                padding: 0.2rem 0.4rem 0.2rem 2.25rem;
                border-radius: 4px;
                cursor: pointer;
                font-size: 0.8125rem;
            }
            #tree-container > .file-item {
                padding-left: 1.75rem;
            }

            .actions {
                margin-left: auto;
                display: flex;
                gap: 0.125rem;
                opacity: 0;
                transition: opacity 0.15s;
            }
            summary:hover .actions,
            .file-item:hover .actions {
                opacity: 1;
            }
            .action-btn {
                background: none;
                border: none;
                padding: 3px;
                color: var(--text-muted);
                border-radius: 4px;
                cursor: pointer;
            }
            .action-btn:hover {
                background: rgba(255, 255, 255, 0.08);
                color: var(--text-main);
            }
            .action-btn.danger:hover {
                color: var(--danger);
            }

            .icon-sm {
                width: 15px;
                height: 15px;
                flex-shrink: 0;
            }
            .chevron {
                transition: transform 0.15s;
                color: var(--text-muted);
            }
            details[open] > summary > .chevron {
                transform: rotate(90deg);
            }
            .name-label {
                white-space: nowrap;
                overflow: hidden;
                text-overflow: ellipsis;
            }

            /* Stats card */
            .card {
                background: rgba(0, 0, 0, 0.2);
                border: 1px solid var(--border);
                border-radius: var(--radius);
                padding: 0.875rem;
                margin-bottom: 0.875rem;
            }
            .progress-bg {
                background: rgba(255, 255, 255, 0.08);
                height: 5px;
                border-radius: 3px;
                overflow: hidden;
                margin-top: 0.625rem;
            }
            .progress-fill {
                height: 100%;
                background: var(--success);
                transition:
                    width 0.3s ease,
                    background-color 0.3s;
                width: 0%;
            }

            /* Format tabs */
            .format-tabs {
                display: flex;
                gap: 2px;
                background: rgba(0, 0, 0, 0.3);
                padding: 3px;
                border-radius: var(--radius);
                border: 1px solid var(--border);
            }
            .tab-btn {
                background: transparent;
                border: none;
                padding: 0.2rem 0.625rem;
                border-radius: 5px;
                font-weight: 500;
                font-size: 0.75rem;
            }
            .tab-btn.active {
                background: var(--accent);
                color: white;
            }

            /* Right layout */
            .right-layout {
                display: flex;
                flex-direction: column;
                gap: 0.875rem;
                flex: 1;
                min-height: 0;
            }
            .box-container {
                display: flex;
                flex-direction: column;
                flex: 1;
                min-height: 0;
            }
            .code-box {
                flex: 1;
                resize: none;
                white-space: pre;
                line-height: 1.5;
                min-height: 0;
            }

            /* Custom ignore panel */
            .ignore-panel {
                background: rgba(0, 0, 0, 0.2);
                border: 1px solid var(--border);
                border-radius: var(--radius);
                padding: 0.625rem;
                margin-top: 0.5rem;
            }
            .ignore-panel input[type="text"] {
                width: 100%;
                padding: 0.4rem 0.6rem;
                font-size: 0.75rem;
                margin-top: 0.375rem;
            }
            .ignore-tag {
                display: inline-flex;
                align-items: center;
                gap: 0.25rem;
                background: rgba(239, 68, 68, 0.1);
                border: 1px solid rgba(239, 68, 68, 0.2);
                color: #fca5a5;
                border-radius: 4px;
                padding: 0.125rem 0.375rem;
                font-size: 0.6875rem;
                font-family: var(--font-mono);
                margin: 0.25rem 0.125rem 0 0;
            }
            .ignore-tag button {
                background: none;
                border: none;
                padding: 0;
                color: inherit;
                cursor: pointer;
                font-size: 0.875rem;
                line-height: 1;
                opacity: 0.6;
            }
            .ignore-tag button:hover {
                opacity: 1;
            }

            /* Toast */
            .toast {
                position: fixed;
                bottom: 1.5rem;
                right: 1.5rem;
                background: rgba(16, 18, 24, 0.95);
                border: 1px solid var(--border);
                border-radius: var(--radius);
                padding: 0.625rem 1rem;
                font-size: 0.8125rem;
                color: var(--text-main);
                backdrop-filter: blur(8px);
                z-index: 100;
                animation:
                    toast-in 0.2s ease,
                    toast-out 0.2s ease 1.8s forwards;
                pointer-events: none;
            }
            @keyframes toast-in {
                from {
                    opacity: 0;
                    transform: translateY(8px);
                }
                to {
                    opacity: 1;
                    transform: translateY(0);
                }
            }
            @keyframes toast-out {
                from {
                    opacity: 1;
                }
                to {
                    opacity: 0;
                }
            }

            /* Undo button in toolbar */
            #btn-undo {
                opacity: 0;
                pointer-events: none;
                transition: opacity 0.15s;
            }
            #btn-undo.visible {
                opacity: 1;
                pointer-events: auto;
            }

            /* Header row */
            .header-row {
                display: flex;
                align-items: center;
                justify-content: space-between;
                margin-bottom: 0.875rem;
            }
            .header-title {
                font-size: 0.8125rem;
                font-weight: 600;
                display: flex;
                align-items: center;
                gap: 0.5rem;
            }
            .toolbar {
                display: flex;
                align-items: center;
                gap: 0.375rem;
            }
            .toolbar-row {
                display: flex;
                align-items: center;
                justify-content: space-between;
                margin-bottom: 0.5rem;
                padding: 0 0.25rem;
            }

            /* Selection helpers */
            textarea {
                user-select: text;
            }
            input[type="text"] {
                user-select: text;
            }
        </style>
    </head>
    <body>
        <div id="app">
            <!-- LEFT PANEL -->
            <div id="left-panel" class="panel">
                <div class="header-row">
                    <div class="header-title mono">
                        <svg
                            class="icon-sm"
                            viewBox="0 0 24 24"
                            fill="none"
                            stroke="currentColor"
                            stroke-width="2"
                        >
                            <path
                                d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4M17 8l-5-5-5 5M12 3v12"
                            />
                        </svg>
                        AI Context Studio
                        <span class="text-xs muted" style="font-weight: 400"
                            >v0.4.1</span
                        >
                    </div>
                    <div class="toolbar">
                        <button
                            id="btn-add-files"
                            class="hidden action-btn text-xs"
                            title="Add more files"
                        >
                            + Add
                        </button>
                        <button
                            id="btn-reset"
                            class="hidden text-xs"
                            title="Reset All"
                        >
                            Clear
                        </button>
                    </div>
                </div>

                <div id="drop-zone">
                    <svg
                        viewBox="0 0 24 24"
                        fill="none"
                        stroke="currentColor"
                        stroke-width="2"
                    >
                        <path
                            d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4M17 8l-5-5-5 5M12 3v12"
                        />
                    </svg>
                    <h3>Drop project folder</h3>
                    <p class="text-sm muted">or click to browse</p>
                    <input
                        type="file"
                        id="file-input"
                        webkitdirectory
                        directory
                        multiple
                        class="hidden"
                    />
                    <input
                        type="file"
                        id="add-file-input"
                        webkitdirectory
                        directory
                        multiple
                        class="hidden"
                    />
                </div>

                <div
                    id="work-area"
                    class="hidden"
                    style="flex: 1; flex-direction: column; overflow: hidden"
                >
                    <div
                        style="
                            display: flex;
                            gap: 0.4rem;
                            margin-bottom: 0.4rem;
                        "
                    >
                        <input
                            type="text"
                            id="search-input"
                            placeholder="Search files…"
                            style="flex: 1; padding: 0.4rem 0.6rem"
                        />
                        <button
                            id="btn-undo"
                            class="action-btn text-xs"
                            title="Undo last action (Ctrl+Z)"
                        >
                            Undo
                        </button>
                    </div>
                    <div class="toolbar-row text-xs muted">
                        <label
                            style="
                                display: flex;
                                align-items: center;
                                gap: 0.4rem;
                                cursor: pointer;
                            "
                        >
                            <input
                                type="checkbox"
                                id="toggle-gitignore"
                                checked
                            />
                            Apply .gitignore
                        </label>
                        <div class="toolbar">
                            <button id="btn-expand" class="action-btn text-xs">
                                Expand
                            </button>
                            <button
                                id="btn-collapse"
                                class="action-btn text-xs"
                            >
                                Collapse
                            </button>
                        </div>
                    </div>

                    <!-- Custom ignore patterns -->
                    <div class="ignore-panel">
                        <div
                            style="
                                display: flex;
                                align-items: center;
                                justify-content: space-between;
                            "
                        >
                            <span class="text-xs muted"
                                >Custom ignore patterns</span
                            >
                        </div>
                        <div id="ignore-tags"></div>
                        <input
                            type="text"
                            id="ignore-input"
                            placeholder="e.g. *.test.ts, .env, .* (dot-dirs) — Enter"
                        />
                    </div>

                    <div id="tree-container"></div>
                </div>
            </div>

            <!-- RIGHT PANEL -->
            <div id="right-panel" class="panel hidden">
                <div class="card">
                    <div
                        style="
                            display: flex;
                            justify-content: space-between;
                            font-size: 0.8125rem;
                        "
                        class="mono"
                    >
                        <span
                            >Selected:
                            <strong id="stat-files" class="text-green"
                                >0</strong
                            >
                            files</span
                        >
                        <span
                            >Tokens: <strong id="stat-tokens">0</strong>
                            <span class="muted">/ 1M</span></span
                        >
                    </div>
                    <div class="progress-bg">
                        <div id="token-bar" class="progress-fill"></div>
                    </div>
                </div>

                <div
                    style="
                        display: flex;
                        align-items: center;
                        justify-content: space-between;
                        margin-bottom: 0.875rem;
                    "
                >
                    <div class="format-tabs">
                        <button class="tab-btn active" data-format="txt">
                            TXT
                        </button>
                        <button class="tab-btn" data-format="md">MD</button>
                        <button class="tab-btn" data-format="xml">XML</button>
                    </div>
                    <div class="toolbar">
                        <button id="btn-copy-export" class="primary">
                            <svg
                                class="icon-sm"
                                viewBox="0 0 24 24"
                                fill="none"
                                stroke="currentColor"
                                stroke-width="2"
                            >
                                <rect
                                    x="9"
                                    y="9"
                                    width="13"
                                    height="13"
                                    rx="2"
                                    ry="2"
                                ></rect>
                                <path
                                    d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"
                                ></path>
                            </svg>
                            Copy for AI
                        </button>
                        <button id="btn-download">
                            <svg
                                class="icon-sm"
                                viewBox="0 0 24 24"
                                fill="none"
                                stroke="currentColor"
                                stroke-width="2"
                            >
                                <path
                                    d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4M7 10l5 5 5-5M12 15V3"
                                />
                            </svg>
                            Download
                        </button>
                    </div>
                </div>

                <div class="right-layout">
                    <div class="box-container">
                        <div
                            style="
                                display: flex;
                                align-items: center;
                                justify-content: space-between;
                                margin-bottom: 0.4rem;
                            "
                        >
                            <h3 class="text-sm" style="font-weight: 600">
                                File Structure
                            </h3>
                            <div class="toolbar">
                                <label
                                    class="text-xs muted"
                                    style="
                                        display: flex;
                                        align-items: center;
                                        gap: 0.35rem;
                                        cursor: pointer;
                                    "
                                >
                                    <input
                                        type="checkbox"
                                        id="fs-selected-only"
                                        checked
                                    />
                                    Selected Only
                                </label>
                                <label
                                    class="text-xs muted"
                                    style="
                                        display: flex;
                                        align-items: center;
                                        gap: 0.35rem;
                                        cursor: pointer;
                                    "
                                >
                                    <input
                                        type="checkbox"
                                        id="fs-show-tokens"
                                    />
                                    Tokens
                                </label>
                                <label
                                    id="fs-token-min-label"
                                    class="text-xs muted hidden"
                                    style="
                                        display: flex;
                                        align-items: center;
                                        gap: 0.25rem;
                                    "
                                >
                                    min
                                    <input
                                        type="number"
                                        id="fs-token-min"
                                        value="500"
                                        min="0"
                                        step="50"
                                        style="
                                            width: 4rem;
                                            padding: 0.1rem 0.3rem;
                                            font-size: 0.6875rem;
                                            font-family: var(--font-mono);
                                            background: rgba(0, 0, 0, 0.35);
                                            border: 1px solid var(--border);
                                            color: var(--text-main);
                                            border-radius: 4px;
                                            outline: none;
                                        "
                                    />
                                </label>
                                <button
                                    id="btn-copy-fs"
                                    class="action-btn"
                                    title="Copy Structure"
                                >
                                    <svg
                                        class="icon-sm"
                                        viewBox="0 0 24 24"
                                        fill="none"
                                        stroke="currentColor"
                                        stroke-width="2"
                                    >
                                        <rect
                                            x="9"
                                            y="9"
                                            width="13"
                                            height="13"
                                            rx="2"
                                            ry="2"
                                        ></rect>
                                        <path
                                            d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"
                                        ></path>
                                    </svg>
                                </button>
                            </div>
                        </div>
                        <textarea
                            id="fs-preview"
                            class="code-box"
                            readonly
                            placeholder="Structure will appear here…"
                        ></textarea>
                    </div>

                    <div class="box-container">
                        <div
                            style="
                                display: flex;
                                align-items: center;
                                justify-content: space-between;
                                margin-bottom: 0.4rem;
                            "
                        >
                            <h3 class="text-sm" style="font-weight: 600">
                                Selection State
                            </h3>
                            <span class="text-xs muted"
                                >Edit & blur to apply</span
                            >
                        </div>
                        <textarea
                            id="state-input"
                            class="code-box"
                            placeholder="Paste state here…&#10;&#10;+ src/&#10;- src/ignore.ts"
                        ></textarea>
                    </div>
                </div>
            </div>
        </div>

        <script>
            // ─── SVG icon strings ───────────────────────────────────────────────
            const ICONS = {
                chevron:
                    '<svg class="icon-sm chevron" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M9 18l6-6-6-6"/></svg>',
                folder: '<svg class="icon-sm text-yellow" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"/></svg>',
                file: '<svg class="icon-sm text-blue" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M13 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V9z"></path><polyline points="13 2 13 9 20 9"></polyline></svg>',
                copy: '<svg class="icon-sm" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path></svg>',
                eyeOff: '<svg class="icon-sm" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M17.94 17.94A10.07 10.07 0 0 1 12 20c-7 0-11-8-11-8a18.45 18.45 0 0 1 5.06-5.94M9.9 4.24A9.12 9.12 0 0 1 12 4c7 0 11 8 11 8a18.5 18.5 0 0 1-2.16 3.19m-6.72-1.07a3 3 0 1 1-4.24-4.24"></path><line x1="1" y1="1" x2="23" y2="23"></line></svg>',
                download:
                    '<svg class="icon-sm" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4M7 10l5 5 5-5M12 15V3"/></svg>',
            };

            // ─── Config ─────────────────────────────────────────────────────────
            const TOKEN_LIMIT = 1_000_000;
            const BINARY_EXTS = new Set([
                "png",
                "jpg",
                "jpeg",
                "gif",
                "ico",
                "webp",
                "bmp",
                "tiff",
                "mp4",
                "mp3",
                "wav",
                "ogg",
                "avi",
                "mov",
                "webm",
                "pdf",
                "zip",
                "tar",
                "gz",
                "7z",
                "rar",
                "bz2",
                "exe",
                "dll",
                "pyc",
                "class",
                "jar",
                "so",
                "dylib",
                "woff",
                "woff2",
                "ttf",
                "eot",
                "otf",
                "bin",
                "iso",
                "img",
                "lock",
            ]);
            // SVG is intentionally NOT in binary list — it's text-based
            const ALWAYS_IGNORED_DIRS = new Set([
                ".git",
                "node_modules",
                ".next",
                "dist",
                "build",
                "coverage",
                "__pycache__",
                ".venv",
                "venv",
            ]);

            // ─── State ──────────────────────────────────────────────────────────
            const state = {
                files: [],
                gitignoreMatchers: [],
                customIgnorePatterns: [],
                useGitignore: true,
                searchQuery: "",
                format: "txt",
                fsSelectedOnly: true,
                expandedPaths: new Set(),
                undoStack: [], // { description, snapshot }
                fsShowTokens: false,
                fsTokenMin: 500,
            };

            // ─── Helpers ────────────────────────────────────────────────────────
            const $ = (id) => document.getElementById(id);
            const estimateTokens = (bytes) => Math.ceil(bytes / 3.5); // slightly more accurate than /4

            function toast(msg) {
                const el = document.createElement("div");
                el.className = "toast";
                el.textContent = msg;
                document.body.appendChild(el);
                setTimeout(() => el.remove(), 2200);
            }

            function flashBtn(btn, text, duration = 1800) {
                const original = btn.innerHTML;
                btn.innerHTML = text;
                setTimeout(() => (btn.innerHTML = original), duration);
            }

            function debounce(fn, ms) {
                let timer;
                return (...args) => {
                    clearTimeout(timer);
                    timer = setTimeout(() => fn(...args), ms);
                };
            }

            async function copyToClipboard(text, successMsg = "Copied") {
                try {
                    await navigator.clipboard.writeText(text);
                    toast(successMsg);
                } catch (_) {
                    toast("Copy failed");
                }
            }

            function formatSize(bytes) {
                if (bytes < 1024) return bytes + "B";
                if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + "K";
                return (bytes / (1024 * 1024)).toFixed(1) + "M";
            }

            function formatTokens(bytes) {
                const t = estimateTokens(bytes);
                return t >= 1000 ? (t / 1000).toFixed(1) + "k" : String(t);
            }

            // ─── Gitignore Parser (supports **, !, ?, negation) ─────────────────
            function parseGitignore(content, basePath) {
                const rules = [];
                for (const raw of content.split("\n")) {
                    const trimmed = raw.trim();
                    if (!trimmed || trimmed.startsWith("#")) continue;

                    let pattern = trimmed;
                    let negate = false;

                    if (pattern.startsWith("!")) {
                        negate = true;
                        pattern = pattern.slice(1);
                    }

                    // Remove leading slash (anchors to base)
                    const anchored = pattern.startsWith("/");
                    pattern = pattern.replace(/^\//, "");

                    // Remove trailing slash (directory marker only — we match both ways)
                    pattern = pattern.replace(/\/$/, "");

                    const regex = gitignorePatternToRegex(pattern, anchored);
                    rules.push({ regex, negate, anchored, basePath });
                }
                return rules;
            }

            function gitignorePatternToRegex(pattern, anchored) {
                // Convert gitignore glob to regex
                let re = "";
                let i = 0;
                while (i < pattern.length) {
                    const c = pattern[i];
                    if (c === "*") {
                        if (pattern[i + 1] === "*") {
                            if (pattern[i + 2] === "/") {
                                re += "(?:.+/)?"; // **/ = zero or more dirs
                                i += 3;
                                continue;
                            }
                            re += ".*"; // ** at end = match everything
                            i += 2;
                            continue;
                        }
                        re += "[^/]*"; // * = anything except /
                    } else if (c === "?") {
                        re += "[^/]";
                    } else if (c === ".") {
                        re += "\\.";
                    } else if (c === "[") {
                        // Pass through character classes
                        const close = pattern.indexOf("]", i);
                        if (close > -1) {
                            re += pattern.slice(i, close + 1);
                            i = close + 1;
                            continue;
                        }
                        re += "\\[";
                    } else {
                        re += c;
                    }
                    i++;
                }

                if (anchored) {
                    return new RegExp("^" + re + "(?:/.*)?$");
                }
                // Unanchored: can match at any depth
                return new RegExp("(?:^|/)" + re + "(?:/.*)?$");
            }

            function isGitignored(filePath, matchers) {
                let ignored = false;
                for (const rule of matchers) {
                    // Make path relative to gitignore base
                    let relPath = filePath;
                    if (rule.basePath && filePath.startsWith(rule.basePath)) {
                        relPath = filePath.slice(rule.basePath.length);
                    }
                    if (rule.regex.test(relPath)) {
                        ignored = !rule.negate;
                    }
                }
                return ignored;
            }

            // ─── Custom ignore pattern matching (checks dirs too) ────────────────
            const _ignoreRegexCache = new Map();
            function matchesCustomIgnore(filePath, patterns) {
                if (patterns.length === 0) return false;
                const parts = filePath.split("/");
                const fileName = parts[parts.length - 1];
                return patterns.some((pattern) => {
                    let regex = _ignoreRegexCache.get(pattern);
                    if (!regex) {
                        regex = gitignorePatternToRegex(pattern, false);
                        _ignoreRegexCache.set(pattern, regex);
                    }
                    if (pattern.includes("/")) {
                        return regex.test(filePath);
                    }
                    // Check filename
                    if (regex.test(fileName)) return true;
                    // Also check each directory segment (e.g. .* matches .hidden/)
                    for (let i = 0; i < parts.length - 1; i++) {
                        if (regex.test(parts[i])) return true;
                    }
                    return false;
                });
            }

            // ─── Undo System ────────────────────────────────────────────────────
            function snapshotState() {
                return state.files.map((f) => ({
                    path: f.path,
                    isSelected: f.isSelected,
                    isExcluded: f.isExcluded,
                }));
            }

            function pushUndo(description) {
                state.undoStack.push({
                    description,
                    snapshot: snapshotState(),
                });
                if (state.undoStack.length > 30) state.undoStack.shift();
                updateUndoBtn();
            }

            function popUndo() {
                const entry = state.undoStack.pop();
                if (!entry) return;
                for (const snap of entry.snapshot) {
                    const f = state.files.find((x) => x.path === snap.path);
                    if (f) {
                        f.isSelected = snap.isSelected;
                        f.isExcluded = snap.isExcluded;
                    }
                }
                renderApp();
                updateUndoBtn();
                toast("Undone: " + entry.description);
            }

            function updateUndoBtn() {
                const btn = $("btn-undo");
                if (state.undoStack.length > 0) {
                    const last = state.undoStack[state.undoStack.length - 1];
                    btn.classList.add("visible");
                    btn.title = `Undo: ${last.description} (Ctrl+Z)`;
                } else {
                    btn.classList.remove("visible");
                }
            }

            // ─── File System Processing ─────────────────────────────────────────
            async function processFileSystem(items, append = false) {
                if (!append) {
                    state.files = [];
                    state.gitignoreMatchers = [];
                    state.expandedPaths.clear();
                    state.undoStack = [];
                }
                const existingPaths = new Set(state.files.map((f) => f.path));

                const entries = [];

                if (items instanceof FileList) {
                    for (const file of items) {
                        entries.push({
                            file,
                            path: file.webkitRelativePath || file.name,
                            name: file.name,
                        });
                    }
                } else {
                    const walk = async (entry, prefix = "") => {
                        if (!entry) return;
                        const fullPath = prefix + entry.name;
                        if (entry.isFile) {
                            const file = await new Promise((res) =>
                                entry.file(res),
                            );
                            entries.push({
                                file,
                                path: fullPath,
                                name: entry.name,
                            });
                        } else if (entry.isDirectory) {
                            const reader = entry.createReader();
                            let all = [],
                                batch;
                            do {
                                batch = await new Promise((res) =>
                                    reader.readEntries(res),
                                );
                                all.push(...batch);
                            } while (batch.length > 0);
                            await Promise.all(
                                all.map((child) => walk(child, fullPath + "/")),
                            );
                        }
                    };
                    const roots = Array.from(items)
                        .filter((i) => i.kind === "file")
                        .map((i) => i.webkitGetAsEntry());
                    await Promise.all(roots.map((e) => walk(e)));
                }

                // First pass: collect .gitignore files
                const gitignoreEntries = entries.filter(
                    (e) => e.name === ".gitignore",
                );
                for (const gi of gitignoreEntries) {
                    try {
                        const content = await gi.file.text();
                        const basePath = gi.path.replace(".gitignore", "");
                        const rules = parseGitignore(content, basePath);
                        state.gitignoreMatchers.push(...rules);
                    } catch (_) {
                        /* skip unreadable */
                    }
                }

                // Second pass: build file list (skip duplicates on append)
                let addedCount = 0;
                for (const item of entries) {
                    if (existingPaths.has(item.path)) continue;
                    const ext = item.name.split(".").pop().toLowerCase();
                    if (BINARY_EXTS.has(ext)) continue;

                    const inAlwaysIgnored = item.path
                        .split("/")
                        .some((part) => ALWAYS_IGNORED_DIRS.has(part));
                    const gitIgnored =
                        state.gitignoreMatchers.length > 0 &&
                        isGitignored(item.path, state.gitignoreMatchers);
                    const isIgnored = inAlwaysIgnored || gitIgnored;

                    state.files.push({
                        path: item.path,
                        name: item.name,
                        size: item.file.size,
                        fileRef: item.file,
                        isSelected: false,
                        isExcluded: false,
                        isGitignored: isIgnored,
                    });
                    addedCount++;
                }
                if (append && addedCount > 0) {
                    toast(`Added ${addedCount} new files`);
                }

                renderApp();
            }

            // ─── Visibility (cached per render cycle) ────────────────────────────
            let _cachedVisible = null;
            function getVisibleFiles() {
                if (_cachedVisible) return _cachedVisible;
                _cachedVisible = state.files.filter((f) => {
                    if (f.isExcluded) return false;
                    if (state.useGitignore && f.isGitignored) return false;
                    if (matchesCustomIgnore(f.path, state.customIgnorePatterns))
                        return false;
                    if (
                        state.searchQuery &&
                        !f.path.toLowerCase().includes(state.searchQuery)
                    )
                        return false;
                    return true;
                });
                return _cachedVisible;
            }

            function computeFolderStats(visibleFiles) {
                const stats = new Map();
                for (const f of visibleFiles) {
                    const parts = f.path.split("/");
                    let current = "";
                    for (let i = 0; i < parts.length - 1; i++) {
                        current += parts[i] + "/";
                        if (!stats.has(current))
                            stats.set(current, { total: 0, selected: 0, bytes: 0 });
                        const s = stats.get(current);
                        s.total++;
                        s.bytes += f.size;
                        if (f.isSelected) s.selected++;
                    }
                }
                return stats;
            }

            // ─── Tree Rendering ─────────────────────────────────────────────────
            function renderApp() {
                _cachedVisible = null;
                const visible = getVisibleFiles();
                state._folderStats = computeFolderStats(visible);
                buildTree();
                updateStats();
                generateFS();
                generateStateText();
            }

            function buildTree() {
                const container = $("tree-container");
                container.innerHTML = "";

                const visible = getVisibleFiles();
                if (visible.length === 0) {
                    container.innerHTML =
                        '<div class="text-sm muted" style="text-align:center;margin-top:2rem;">No files found.</div>';
                    return;
                }

                // Build nested map
                const root = {};
                for (const f of visible) {
                    const parts = f.path.split("/");
                    let node = root;
                    for (let i = 0; i < parts.length; i++) {
                        const key = parts[i];
                        if (i === parts.length - 1) {
                            node[key] = f; // leaf
                        } else {
                            if (!node[key] || node[key].fileRef) node[key] = {};
                            node = node[key];
                        }
                    }
                }

                const isFirstRender =
                    state.expandedPaths.size === 0 && !state.searchQuery;
                const isSearching = state.searchQuery.length > 0;

                container.appendChild(
                    buildNodes(root, "", 0, isFirstRender, isSearching),
                );
            }

            function buildNodes(
                obj,
                prefix,
                depth,
                isFirstRender,
                isSearching,
            ) {
                const frag = document.createDocumentFragment();
                const keys = Object.keys(obj).sort((a, b) => {
                    const da = !obj[a].fileRef,
                        db = !obj[b].fileRef;
                    return da === db ? a.localeCompare(b) : da ? -1 : 1;
                });

                for (const key of keys) {
                    const item = obj[key];
                    const path = prefix ? `${prefix}/${key}` : key;
                    const isDir = !item.fileRef;

                    if (isDir) {
                        frag.appendChild(
                            buildFolder(
                                key,
                                path,
                                item,
                                depth,
                                isFirstRender,
                                isSearching,
                            ),
                        );
                    } else {
                        frag.appendChild(buildFile(key, item));
                    }
                }
                return frag;
            }

            function buildFolder(
                name,
                path,
                children,
                depth,
                isFirstRender,
                isSearching,
            ) {
                const details = document.createElement("details");

                const shouldOpen =
                    isSearching ||
                    (isFirstRender && depth === 0) ||
                    state.expandedPaths.has(path);

                if (shouldOpen) {
                    details.open = true;
                    state.expandedPaths.add(path);
                }

                details.addEventListener("toggle", () => {
                    if (details.open) state.expandedPaths.add(path);
                    else state.expandedPaths.delete(path);
                });

                // Folder files — use pre-computed stats (O(1) lookup)
                const prefix = path + "/";
                const fStats = state._folderStats.get(prefix) || {
                    total: 0,
                    selected: 0,
                };
                const selectedCount = fStats.selected;
                const allSelected =
                    fStats.selected === fStats.total && fStats.total > 0;

                const summary = document.createElement("summary");

                const cb = document.createElement("input");
                cb.type = "checkbox";
                cb.checked = allSelected;
                cb.indeterminate = selectedCount > 0 && !allSelected;
                cb.onclick = (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    pushUndo(
                        allSelected ? `Deselect ${name}/` : `Select ${name}/`,
                    );
                    for (const f of getVisibleFiles()) {
                        if (f.path.startsWith(prefix))
                            f.isSelected = !allSelected;
                    }
                    renderApp();
                };

                const actions = document.createElement("div");
                actions.className = "actions";
                const btnExclude = document.createElement("button");
                btnExclude.className = "action-btn danger";
                btnExclude.title = "Exclude folder";
                btnExclude.innerHTML = ICONS.eyeOff;
                btnExclude.onclick = (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    excludePath(prefix, name + "/");
                };
                actions.appendChild(btnExclude);

                const folderTokens = formatTokens(fStats.bytes);

                summary.innerHTML = ICONS.chevron + " ";
                summary.appendChild(cb);
                summary.insertAdjacentHTML(
                    "beforeend",
                    ` ${ICONS.folder} <span class="name-label mono text-sm">${name}</span> <span class="muted" style="font-size:0.625rem;opacity:0.5">~${folderTokens}</span>`,
                );
                summary.appendChild(actions);

                details.appendChild(summary);
                details.appendChild(
                    buildNodes(children, path, depth + 1, false, isSearching),
                );
                return details;
            }

            function buildFile(name, fileObj) {
                const div = document.createElement("div");
                div.className = "file-item";

                const cb = document.createElement("input");
                cb.type = "checkbox";
                cb.checked = fileObj.isSelected;
                cb.onclick = (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    fileObj.isSelected = !fileObj.isSelected;
                    renderApp();
                };

                const actions = document.createElement("div");
                actions.className = "actions";

                const btnCopy = document.createElement("button");
                btnCopy.className = "action-btn";
                btnCopy.title = "Copy content";
                btnCopy.innerHTML = ICONS.copy;
                btnCopy.onclick = async (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    const content = await fileObj.fileRef.text();
                    copyToClipboard(
                        `// File: ${fileObj.path}\n${content}`,
                        "Copied: " + name,
                    );
                };

                const btnExclude = document.createElement("button");
                btnExclude.className = "action-btn danger";
                btnExclude.title = "Exclude file";
                btnExclude.innerHTML = ICONS.eyeOff;
                btnExclude.onclick = (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    excludePath(fileObj.path, name);
                };

                actions.appendChild(btnCopy);
                actions.appendChild(btnExclude);

                div.appendChild(cb);
                div.insertAdjacentHTML(
                    "beforeend",
                    ` ${ICONS.file} <span class="name-label mono text-sm">${name}</span> <span class="muted text-xs">${formatSize(fileObj.size)}</span> <span class="muted" style="font-size:0.625rem;opacity:0.5">~${formatTokens(fileObj.size)}</span>`,
                );
                div.appendChild(actions);

                div.onclick = (e) => {
                    if (
                        e.target.tagName === "INPUT" ||
                        e.target.closest("button")
                    )
                        return;
                    fileObj.isSelected = !fileObj.isSelected;
                    renderApp();
                };

                return div;
            }

            // ─── Actions ────────────────────────────────────────────────────────
            function excludePath(path, label) {
                pushUndo(`Exclude ${label || path}`);
                for (const f of state.files) {
                    if (f.path === path || f.path.startsWith(path)) {
                        f.isExcluded = true;
                        f.isSelected = false;
                    }
                }
                renderApp();
            }

            function updateStats() {
                const selected = state.files.filter(
                    (f) => f.isSelected && !f.isExcluded,
                );
                const totalBytes = selected.reduce((sum, f) => sum + f.size, 0);
                const tokens = estimateTokens(totalBytes);

                $("stat-files").textContent = selected.length;
                $("stat-tokens").textContent =
                    tokens >= 1000 ? (tokens / 1000).toFixed(1) + "k" : tokens;

                const pct = Math.min((tokens / TOKEN_LIMIT) * 100, 100);
                const bar = $("token-bar");
                bar.style.width = pct + "%";
                bar.style.backgroundColor =
                    pct > 90
                        ? "var(--danger)"
                        : pct > 75
                          ? "var(--warning)"
                          : "var(--success)";
            }

            // ─── FS Generator ───────────────────────────────────────────────────
            function generateFS() {
                let files = getVisibleFiles();
                if (state.fsSelectedOnly)
                    files = files.filter((f) => f.isSelected);

                const showTok = state.fsShowTokens;
                const dirs = new Map();
                for (const f of files) {
                    const parts = f.path.split("/");
                    const name = parts.pop();
                    const dir = parts.length > 0 ? parts.join("/") + "/" : "/";
                    if (!dirs.has(dir)) dirs.set(dir, []);
                    const tok = estimateTokens(f.size);
                    const label = showTok && tok >= state.fsTokenMin ? `${name} ${formatTokens(f.size)}` : name;
                    dirs.get(dir).push(label);
                }

                let out = "";
                for (const dir of Array.from(dirs.keys()).sort()) {
                    out += `${dir}\n* ${dirs.get(dir).join(", ")}\n\n`;
                }
                $("fs-preview").value = out.trim();
            }

            // ─── State Generator & Parser ───────────────────────────────────────
            function generateStateText() {
                if (document.activeElement === $("state-input")) return;

                const lines = [];
                const allNonExcluded = state.files.filter((f) => !f.isExcluded);

                // Find fully-selected directories
                const dirMap = new Map(); // dirPath -> { total, selected }
                for (const f of allNonExcluded) {
                    const parts = f.path.split("/");
                    let current = "";
                    for (let i = 0; i < parts.length - 1; i++) {
                        current += parts[i] + "/";
                        if (!dirMap.has(current))
                            dirMap.set(current, { total: 0, selected: 0 });
                        const d = dirMap.get(current);
                        d.total++;
                        if (f.isSelected) d.selected++;
                    }
                }

                // Excluded files
                for (const f of state.files) {
                    if (f.isExcluded) lines.push(`- ${f.path}`);
                }

                // Find top-level fully-selected dirs (avoid redundant children)
                const coveredPaths = new Set();
                const sortedDirs = Array.from(dirMap.keys()).sort(
                    (a, b) => a.length - b.length,
                );

                for (const dir of sortedDirs) {
                    const info = dirMap.get(dir);
                    // Check if parent already covers this
                    const parentCovered = Array.from(coveredPaths).some((p) =>
                        dir.startsWith(p),
                    );
                    if (parentCovered) continue;

                    if (info.total > 0 && info.selected === info.total) {
                        lines.push(`+ ${dir}`);
                        coveredPaths.add(dir);
                    }
                }

                // Individual selected files not covered by a directory
                for (const f of allNonExcluded) {
                    if (!f.isSelected) continue;
                    const covered = Array.from(coveredPaths).some((d) =>
                        f.path.startsWith(d),
                    );
                    if (!covered) lines.push(`+ ${f.path}`);
                }

                // Sort: - (excluded) first, then + folders, then + files, alpha within
                lines.sort((a, b) => {
                    const ta = a[0],
                        tb = b[0];
                    if (ta !== tb) return ta === "-" ? -1 : 1;
                    const pa = a.slice(2),
                        pb = b.slice(2);
                    const fa = pa.endsWith("/"),
                        fb = pb.endsWith("/");
                    if (fa !== fb) return fa ? -1 : 1;
                    return pa.localeCompare(pb);
                });
                $("state-input").value = lines.join("\n");
            }

            function parseStateText() {
                const text = $("state-input").value;
                const lines = text
                    .split("\n")
                    .map((l) => l.trim())
                    .filter(
                        (l) => l && (l.startsWith("+") || l.startsWith("-")),
                    );

                // Reset all
                state.files.forEach((f) => {
                    f.isExcluded = false;
                    f.isSelected = false;
                });

                for (const line of lines) {
                    const action = line[0];
                    const path = line.slice(1).trim();
                    if (!path) continue;

                    for (const f of state.files) {
                        const matches =
                            f.path === path ||
                            (path.endsWith("/") && f.path.startsWith(path));
                        if (matches) {
                            if (action === "+") {
                                f.isSelected = true;
                                f.isExcluded = false;
                            }
                            if (action === "-") {
                                f.isExcluded = true;
                                f.isSelected = false;
                            }
                        }
                    }
                }
                renderApp();
            }

            // ─── Export ──────────────────────────────────────────────────────────
            async function generateExportContent() {
                const selected = state.files.filter(
                    (f) => f.isSelected && !f.isExcluded,
                );
                if (selected.length === 0) return "No files selected.";

                // Parallel read
                const contents = await Promise.all(
                    selected.map(async (f) => ({
                        path: f.path,
                        name: f.name,
                        content: await f.fileRef.text(),
                    })),
                );

                const fs = $("fs-preview").value;
                const fmt = state.format;

                if (fmt === "txt") {
                    let out = `FILE STRUCTURE:\n${fs}\n\n${"=".repeat(64)}\nFILES EXPORT (${contents.length} files)\n${"=".repeat(64)}\n\n`;
                    for (const { path, content } of contents) {
                        out += `--- BEGIN FILE: ${path} ---\n${content}\n--- END FILE: ${path} ---\n\n`;
                    }
                    return out;
                }

                if (fmt === "md") {
                    let out = `# Project Export\n\n## File Structure\n\`\`\`text\n${fs}\n\`\`\`\n\n## Files\n\n`;
                    for (const { path, name, content } of contents) {
                        const ext = name.split(".").pop();
                        out += `### \`${path}\`\n\`\`\`${ext}\n${content}\n\`\`\`\n\n`;
                    }
                    return out;
                }

                if (fmt === "xml") {
                    let out = `<project>\n  <file_structure><![CDATA[\n${fs}\n  ]]></file_structure>\n\n`;
                    for (const { path, content } of contents) {
                        out += `  <file path="${path}">\n<![CDATA[\n${content}\n]]>\n  </file>\n`;
                    }
                    return out + `</project>`;
                }

                return "";
            }

            // ─── Custom Ignore Patterns UI ──────────────────────────────────────
            function renderIgnoreTags() {
                const container = $("ignore-tags");
                container.innerHTML = "";
                for (let i = 0; i < state.customIgnorePatterns.length; i++) {
                    const tag = document.createElement("span");
                    tag.className = "ignore-tag";
                    tag.innerHTML = `${state.customIgnorePatterns[i]} <button onclick="removeIgnorePattern(${i})">&times;</button>`;
                    container.appendChild(tag);
                }
            }

            function addIgnorePattern(pattern) {
                const clean = pattern.trim();
                if (!clean || state.customIgnorePatterns.includes(clean))
                    return;
                state.customIgnorePatterns.push(clean);
                renderIgnoreTags();
                renderApp();
            }

            function removeIgnorePattern(index) {
                state.customIgnorePatterns.splice(index, 1);
                renderIgnoreTags();
                renderApp();
            }

            // ─── Event Binding ──────────────────────────────────────────────────
            const dropZone = $("drop-zone");
            const fileInput = $("file-input");

            function showWorkspace() {
                $("drop-zone").classList.add("hidden");
                const wa = $("work-area");
                wa.classList.remove("hidden");
                wa.style.display = "flex";
                $("right-panel").classList.remove("hidden");
                $("btn-reset").classList.remove("hidden");
                $("btn-add-files").classList.remove("hidden");
            }

            // Add more files
            const addFileInput = $("add-file-input");
            $("btn-add-files").onclick = () => addFileInput.click();
            addFileInput.onchange = async (e) => {
                if (e.target.files.length > 0) {
                    await processFileSystem(e.target.files, true);
                    e.target.value = "";
                }
            };

            dropZone.ondragover = (e) => {
                e.preventDefault();
                dropZone.classList.add("dragover");
            };
            dropZone.ondragleave = (e) => {
                e.preventDefault();
                dropZone.classList.remove("dragover");
            };
            dropZone.ondrop = async (e) => {
                e.preventDefault();
                dropZone.classList.remove("dragover");
                if (e.dataTransfer.items) {
                    showWorkspace();
                    await processFileSystem(e.dataTransfer.items);
                }
            };
            dropZone.onclick = () => fileInput.click();
            fileInput.onchange = async (e) => {
                if (e.target.files.length > 0) {
                    showWorkspace();
                    await processFileSystem(e.target.files);
                }
            };

            $("btn-reset").onclick = () => location.reload();
            $("btn-undo").onclick = () => {
                if (state.undoStack.length > 0) popUndo();
            };

            const _debouncedRender = debounce(() => renderApp(), 120);
            $("search-input").oninput = (e) => {
                state.searchQuery = e.target.value.toLowerCase();
                _debouncedRender();
            };

            $("toggle-gitignore").onchange = (e) => {
                state.useGitignore = e.target.checked;
                renderApp();
            };

            $("btn-expand").onclick = () => {
                $("tree-container")
                    .querySelectorAll("details")
                    .forEach((d) => {
                        d.open = true;
                        // Extract real path from the tree structure
                        const label = d.querySelector(".name-label");
                        if (label) {
                            // Walk up to build full path
                            const path = getDetailsPath(d);
                            if (path) state.expandedPaths.add(path);
                        }
                    });
            };

            $("btn-collapse").onclick = () => {
                $("tree-container")
                    .querySelectorAll("details")
                    .forEach((d) => (d.open = false));
                state.expandedPaths.clear();
            };

            // Helper to reconstruct full path from nested details
            function getDetailsPath(details) {
                const parts = [];
                let el = details;
                while (el && el !== $("tree-container")) {
                    if (el.tagName === "DETAILS") {
                        const label = el.querySelector(
                            ":scope > summary .name-label",
                        );
                        if (label) parts.unshift(label.textContent);
                    }
                    el = el.parentElement;
                }
                return parts.join("/");
            }

            $("fs-selected-only").onchange = (e) => {
                state.fsSelectedOnly = e.target.checked;
                generateFS();
            };

            $("fs-show-tokens").onchange = (e) => {
                state.fsShowTokens = e.target.checked;
                const minLabel = $("fs-token-min-label");
                if (e.target.checked) {
                    minLabel.classList.remove("hidden");
                    minLabel.style.display = "flex";
                } else {
                    minLabel.classList.add("hidden");
                }
                generateFS();
            };

            $("fs-token-min").onchange = (e) => {
                state.fsTokenMin = Math.max(0, parseInt(e.target.value) || 0);
                generateFS();
            };

            $("btn-copy-fs").onclick = () =>
                copyToClipboard($("fs-preview").value, "Structure copied");

            document.querySelectorAll(".tab-btn").forEach((btn) => {
                btn.onclick = () => {
                    document
                        .querySelectorAll(".tab-btn")
                        .forEach((b) => b.classList.remove("active"));
                    btn.classList.add("active");
                    state.format = btn.dataset.format;
                };
            });

            $("state-input").onblur = parseStateText;

            $("btn-copy-export").onclick = async function () {
                const orig = this.innerHTML;
                this.innerHTML = "Processing…";
                this.disabled = true;
                try {
                    const content = await generateExportContent();
                    await navigator.clipboard.writeText(content);
                    toast("Exported to clipboard");
                    flashBtn(this, ICONS.copy + " Copied!", 1500);
                } catch (e) {
                    flashBtn(this, "Error!", 1500);
                } finally {
                    this.disabled = false;
                    // Restore after flash
                    setTimeout(() => {
                        this.innerHTML = orig;
                    }, 1600);
                }
            };

            $("btn-download").onclick = async function () {
                const orig = this.innerHTML;
                this.innerHTML = "Preparing…";
                this.disabled = true;
                try {
                    const content = await generateExportContent();
                    const blob = new Blob([content], { type: "text/plain" });
                    const a = document.createElement("a");
                    a.href = URL.createObjectURL(blob);
                    a.download = `context_export.${state.format}`;
                    a.click();
                    URL.revokeObjectURL(a.href);
                    toast("Download started");
                } catch (e) {
                    toast("Download failed");
                } finally {
                    this.disabled = false;
                    this.innerHTML = orig;
                }
            };

            $("ignore-input").onkeydown = (e) => {
                if (e.key === "Enter") {
                    const val = e.target.value.trim();
                    if (val) {
                        // Support comma-separated
                        val.split(",").forEach((p) =>
                            addIgnorePattern(p.trim()),
                        );
                        e.target.value = "";
                    }
                }
            };

            // Keyboard shortcuts
            document.addEventListener("keydown", (e) => {
                const inInput =
                    document.activeElement.tagName === "TEXTAREA" ||
                    document.activeElement.tagName === "INPUT";

                // Escape: clear search
                if (e.key === "Escape") {
                    const search = $("search-input");
                    if (search.value) {
                        search.value = "";
                        state.searchQuery = "";
                        renderApp();
                        search.blur();
                    }
                    return;
                }

                if (inInput) return;

                // Ctrl+Z: undo
                if (
                    (e.ctrlKey || e.metaKey) &&
                    e.key === "z" &&
                    state.undoStack.length > 0
                ) {
                    e.preventDefault();
                    popUndo();
                    return;
                }

                // Ctrl+A: select/deselect all visible
                if ((e.ctrlKey || e.metaKey) && e.key === "a") {
                    if (state.files.length === 0) return;
                    e.preventDefault();
                    const visible = getVisibleFiles();
                    const allSelected = visible.every((f) => f.isSelected);
                    pushUndo(allSelected ? "Deselect all" : "Select all");
                    visible.forEach((f) => (f.isSelected = !allSelected));
                    renderApp();
                }
            });
        </script>
    </body>
</html>
